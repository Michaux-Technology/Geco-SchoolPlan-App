const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const http = require('http');
const socketIo = require('socket.io');
const jwt = require('jsonwebtoken');
const authRoutes = require('./routes/auth');
const Planning = require('./models/Planning');
const Uhr = require('./models/Uhr');
const Surveillance = require('./models/Surveillance');
const Enseignant = require('./models/Enseignant');
const Matiere = require('./models/Matiere');
const Classe = require('./models/Classe');
const Salle = require('./models/Salle');
const Cours = require('./models/Cours');
const Annotation = require('./models/Annotation');
require('dotenv').config();

// Configuration JWT et utilisateurs par d√©faut
const JWT_SECRET = process.env.JWT_SECRET || 'votre_secret_jwt';
const defaultUsers = [
  {
    username: 'enseignant',
    password: '1234',
    role: 'enseignant'
  },
  {
    username: 'eleve',
    password: '1234',
    role: 'eleve'
  }
];

// Stockage des tentatives de connexion
const loginAttempts = new Map();
const MAX_LOGIN_ATTEMPTS = 10;
const BLOCK_DURATION = 15 * 60 * 1000; // 15 minutes

// Middleware de v√©rification des tentatives de connexion
const checkLoginAttempts = (req, res, next) => {
  const ip = req.ip;
  const attempts = loginAttempts.get(ip) || { count: 0, lastAttempt: 0 };
  if (attempts.count >= MAX_LOGIN_ATTEMPTS) {
    const timeSinceLastAttempt = Date.now() - attempts.lastAttempt;
    if (timeSinceLastAttempt < BLOCK_DURATION) {
      const remainingTime = Math.ceil((BLOCK_DURATION - timeSinceLastAttempt) / 1000 / 60);
      return res.status(429).json({
        message: `Trop de tentatives de connexion. Veuillez r√©essayer dans ${remainingTime} minutes.`
      });
    } else {
      loginAttempts.delete(ip);
    }
  }
  next();
};

// Fonction pour obtenir le num√©ro de la semaine
function getWeekNumber(date) {
  const d = new Date(date);
  d.setHours(0, 0, 0, 0);
  d.setDate(d.getDate() + 3 - (d.getDay() + 6) % 7);
  const week1 = new Date(d.getFullYear(), 0, 4);
  return 1 + Math.round(((d - week1) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
}

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: {
    origin: "http://localhost:5173",
    methods: ["GET", "POST"]
  }
});

// Middleware
app.use(cors());
app.use(express.json());

// Initialiser les donn√©es
let planning = [];
let surveillances = [];
let zeitslots = [];
let enseignants = [];
let cours = [];
let classes = [];
let matieres = [];
let salles = [];
let uhrs = [];

// Fonction pour charger les donn√©es
async function loadData() {
  try {
    planning = await Planning.find();
    surveillances = await Surveillance.find().populate('enseignant');
    zeitslots = await Uhr.find();
    enseignants = await Enseignant.find();
    cours = await Cours.find();
    classes = await Classe.find();
    matieres = await Matiere.find();
    salles = await Salle.find();
    uhrs = await Uhr.find();

    console.log('Donn√©es charg√©es:');
    console.log('- Planning:', planning.length);
    console.log('- Surveillances:', surveillances.length);
    console.log('- Zeitslots:', zeitslots.length);
    console.log('- Enseignants:', enseignants.length);
    console.log('- Cours:', cours.length);
    console.log('- Classes:', classes.length);
    console.log('- Mati√®res:', matieres.length);
    console.log('- Salles:', salles.length);
    console.log('- Heures:', uhrs.length);
  } catch (error) {
    console.error('Erreur lors du chargement des donn√©es:', error);
  }
}

// Charger les donn√©es au d√©marrage
loadData();

// Fonction pour initialiser les cr√©neaux horaires
async function initializeUhr() {
  try {
    const count = await Uhr.countDocuments();
    console.log('V√©rification de la collection Uhr:', count);
    
    if (count === 0) {
      console.log('Initialisation des cr√©neaux horaires...');
      const zeitslots = [
        { nummer: 1, zeitslot: '7:40 - 8:25' },
        { nummer: 2, zeitslot: '8:35 - 9:20' },
        { nummer: 3, zeitslot: '9:30 - 10:15' },
        { nummer: 4, zeitslot: '10:40 - 11:25' },
        { nummer: 5, zeitslot: '11:35 - 12:20' },
        { nummer: 6, zeitslot: '12:30 - 13:15' },
        { nummer: 7, zeitslot: '13:45 - 14:20' },
        { nummer: 8, zeitslot: '14:35 - 15:20' }
      ];
      
      const result = await Uhr.insertMany(zeitslots);
      console.log('‚úÖ Cr√©neaux horaires initialis√©s avec succ√®s:', result);
    } else {
      console.log('‚ÑπÔ∏è Les cr√©neaux horaires existent d√©j√†');
    }
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'initialisation des cr√©neaux horaires:', error);
  }
}

// Connexion √† MongoDB avec gestion des erreurs am√©lior√©e
const MONGODB_URI = 'mongodb://192.168.1.104:27017/Geco-SchoolPlan';

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('Connect√© √† MongoDB');

    // Initialiser les tranches horaires si la collection est vide
    await Uhr.initializeUhrs();
    
    // Charger les donn√©es
    await loadData();
  } catch (error) {
    console.error('Erreur de connexion √† MongoDB:', error);
    process.exit(1);
  }
};

// Appeler la connexion
connectDB();

// Gestion des √©v√©nements de d√©connexion
mongoose.connection.on('disconnected', () => {
  console.log('‚ö†Ô∏è D√©connect√© de MongoDB');
});

mongoose.connection.on('error', (err) => {
  console.error('‚ùå Erreur MongoDB:', err);
});

// Routes
app.use('/api/auth', authRoutes);

// Routes pour les mati√®res
app.get('/api/matieres', async (req, res) => {
  try {
    const matieres = await Matiere.find().sort({ nom: 1 });
    res.json(matieres);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

app.post('/api/matieres', async (req, res) => {
  try {
    const matiere = new Matiere(req.body);
    const newMatiere = await matiere.save();
    res.status(201).json(newMatiere);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

app.put('/api/matieres/:id', async (req, res) => {
  try {
    const matiere = await Matiere.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    res.json(matiere);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

app.delete('/api/matieres/:id', async (req, res) => {
  try {
    await Matiere.findByIdAndDelete(req.params.id);
    res.json({ message: 'Mati√®re supprim√©e' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Routes pour les classes
app.get('/api/classes', async (req, res) => {
  try {
    const classes = await Classe.find().sort({ niveau: 1, nom: 1 });
    res.json(classes);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

app.post('/api/classes', async (req, res) => {
  try {
    const classe = new Classe(req.body);
    const newClasse = await classe.save();
    res.status(201).json(newClasse);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

app.put('/api/classes/:id', async (req, res) => {
  try {
    const classe = await Classe.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    res.json(classe);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

app.delete('/api/classes/:id', async (req, res) => {
  try {
    await Classe.findByIdAndDelete(req.params.id);
    res.json({ message: 'Classe supprim√©e' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Routes pour les salles
app.get('/api/salles', async (req, res) => {
  try {
    const salles = await Salle.find().sort({ nom: 1 });
    res.json(salles);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

app.post('/api/salles', async (req, res) => {
  try {
    const salle = new Salle(req.body);
    const newSalle = await salle.save();
    res.status(201).json(newSalle);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

app.put('/api/salles/:id', async (req, res) => {
  try {
    const salle = await Salle.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    res.json(salle);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
});

app.delete('/api/salles/:id', async (req, res) => {
  try {
    await Salle.findByIdAndDelete(req.params.id);
    res.json({ message: 'Salle supprim√©e' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Routes pour les cours
app.get('/api/cours', async (req, res) => {
  try {
    const cours = await Cours.find().sort({ jour: 1, heure: 1 });
    res.json(cours);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

app.post('/api/cours', async (req, res) => {
  try {
    const coursData = req.body;
    const newCours = await Cours.create({
      classe: coursData.classe,
      enseignants: coursData.enseignants,
      matiere: coursData.matiere,
      salle: coursData.salle,
      jour: coursData.jour,
      heure: coursData.heure,
      uhr: coursData.uhr,
      semaine: coursData.semaine,
      annee: coursData.annee || new Date().getFullYear(),
      commentaire: coursData.commentaire || ''
    });
    res.status(201).json(newCours);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.put('/api/cours/:id', async (req, res) => {
  try {
    console.log('‚úèÔ∏è Route PUT /api/cours/:id appel√©e pour le cours:', req.params.id);
    console.log('üìù Donn√©es re√ßues:', req.body);
    
    // R√©cup√©rer le cours avant de le modifier pour avoir les informations des enseignants
    const coursToUpdate = await Cours.findById(req.params.id);
    if (!coursToUpdate) {
      console.log('‚ùå Cours non trouv√©:', req.params.id);
      res.status(404).json({ message: 'Cours non trouv√©' });
      return;
    }
    
    // Extraire les IDs des enseignants du cours (avant modification)
    const enseignantsIdsBefore = coursToUpdate.enseignants.map(e => e.id.toString());
    console.log('‚úèÔ∏è Modification du cours pour les enseignants:', enseignantsIdsBefore);
    console.log('üìã Enseignants du cours:', coursToUpdate.enseignants);
    
    const coursData = req.body;
    const updatedCours = await Cours.findByIdAndUpdate(req.params.id, coursData, { new: true });
    
    console.log('‚úÖ Cours mis √† jour:', updatedCours._id);
    console.log('üìã Nouveau statut du cours:', {
      annule: updatedCours.annule,
      remplace: updatedCours.remplace
    });
    
    // Envoyer la mise √† jour g√©n√©rale
    io.emit('coursUpdate', await Cours.find());
    
    // Envoyer une mise √† jour sp√©cifique √† tous les enseignants concern√©s
    console.log('üì§ Envoi de mises √† jour aux enseignants apr√®s modification:', enseignantsIdsBefore);
    console.log('üîå Sockets connect√©s:', io.sockets.sockets.size);
    
    // Parcourir tous les sockets connect√©s et envoyer les mises √† jour
    io.sockets.sockets.forEach((clientSocket) => {
      console.log(`üîç V√©rification du socket ${clientSocket.id}:`, {
        subscribedEnseignantId: clientSocket.subscribedEnseignantId,
        enseignantsIds: enseignantsIdsBefore,
        isMatch: clientSocket.subscribedEnseignantId && enseignantsIdsBefore.includes(clientSocket.subscribedEnseignantId)
      });
      
      if (clientSocket.subscribedEnseignantId && enseignantsIdsBefore.includes(clientSocket.subscribedEnseignantId)) {
        console.log(`üì§ Envoi de mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId} apr√®s modification`);
        try {
          sendTeacherUpdate(clientSocket, clientSocket.subscribedEnseignantId);
          console.log(`‚úÖ Mise √† jour envoy√©e avec succ√®s √† l'enseignant ${clientSocket.subscribedEnseignantId}`);
        } catch (error) {
          console.error(`‚ùå Erreur lors de l'envoi de la mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId}:`, error);
        }
      }
    });
    
    res.json(updatedCours);
  } catch (error) {
    console.error('Erreur lors de la modification du cours:', error);
    res.status(500).json({ error: error.message });
  }
});

app.put('/api/cours/:id/annuler', async (req, res) => {
  try {
    console.log('üö´ Route d\'annulation appel√©e pour le cours:', req.params.id);
    console.log('üö´ M√©thode HTTP:', req.method);
    console.log('üö´ URL compl√®te:', req.originalUrl);
    console.log('üö´ Headers:', req.headers);
    console.log('üö´ Body:', req.body);
    
    // R√©cup√©rer le cours avant de le modifier pour avoir les informations des enseignants
    const coursToUpdate = await Cours.findById(req.params.id);
    if (!coursToUpdate) {
      console.log('‚ùå Cours non trouv√©:', req.params.id);
      res.status(404).json({ message: 'Cours non trouv√©' });
      return;
    }
    
    // Extraire les IDs des enseignants du cours
    const enseignantsIds = coursToUpdate.enseignants.map(e => e.id.toString());
    console.log('üö´ Annulation du cours pour les enseignants:', enseignantsIds);
    
    // Mettre √† jour le cours
    const updatedCours = await Cours.findByIdAndUpdate(
      req.params.id,
      { annule: true, remplace: false },
      { new: true }
    );
    
    console.log('‚úÖ Cours mis √† jour:', updatedCours._id);
    
    // Envoyer une mise √† jour sp√©cifique √† tous les enseignants concern√©s
    console.log('üì§ Envoi de mises √† jour aux enseignants apr√®s annulation:', enseignantsIds);
    console.log('üîå Sockets connect√©s:', io.sockets.sockets.size);
    
    // Parcourir tous les sockets connect√©s et envoyer les mises √† jour
    io.sockets.sockets.forEach((clientSocket) => {
      console.log(`üîç V√©rification du socket ${clientSocket.id}:`, {
        subscribedEnseignantId: clientSocket.subscribedEnseignantId,
        enseignantsIds: enseignantsIds,
        isMatch: clientSocket.subscribedEnseignantId && enseignantsIds.includes(clientSocket.subscribedEnseignantId)
      });
      
      if (clientSocket.subscribedEnseignantId && enseignantsIds.includes(clientSocket.subscribedEnseignantId)) {
        console.log(`üì§ Envoi de mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId} apr√®s annulation`);
        try {
          sendTeacherUpdate(clientSocket, clientSocket.subscribedEnseignantId);
          console.log(`‚úÖ Mise √† jour envoy√©e avec succ√®s √† l'enseignant ${clientSocket.subscribedEnseignantId}`);
        } catch (error) {
          console.error(`‚ùå Erreur lors de l'envoi de la mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId}:`, error);
        }
      }
    });
    
    res.json(updatedCours);
  } catch (error) {
    console.error('Erreur lors de l\'annulation du cours:', error);
    res.status(500).json({ message: error.message });
  }
});

app.put('/api/cours/:id/remplacer', async (req, res) => {
  try {
    // R√©cup√©rer le cours avant de le modifier pour avoir les informations des enseignants
    const coursToUpdate = await Cours.findById(req.params.id);
    if (!coursToUpdate) {
      res.status(404).json({ message: 'Cours non trouv√©' });
      return;
    }
    
    // Extraire les IDs des enseignants du cours (avant modification)
    const enseignantsIdsBefore = coursToUpdate.enseignants.map(e => e.id.toString());
    console.log('üîÑ Remplacement du cours pour les enseignants:', enseignantsIdsBefore);
    
    const { enseignant, matiere, salle } = req.body;
    const updatedCours = await Cours.findByIdAndUpdate(
      req.params.id,
      { 
        enseignant: enseignant || undefined,
        matiere: matiere || undefined,
        salle: salle || undefined,
        remplace: true,
        annule: false
      },
      { new: true }
    );
    
    // Envoyer la mise √† jour g√©n√©rale
    io.emit('coursUpdate', await Cours.find());
    
    // Envoyer une mise √† jour sp√©cifique √† tous les enseignants concern√©s
    console.log('üì§ Envoi de mises √† jour aux enseignants apr√®s remplacement:', enseignantsIdsBefore);
    console.log('üîå Sockets connect√©s:', io.sockets.sockets.size);
    
    // Parcourir tous les sockets connect√©s et envoyer les mises √† jour
    io.sockets.sockets.forEach((clientSocket) => {
      console.log(`üîç V√©rification du socket ${clientSocket.id}:`, {
        subscribedEnseignantId: clientSocket.subscribedEnseignantId,
        enseignantsIds: enseignantsIdsBefore,
        isMatch: clientSocket.subscribedEnseignantId && enseignantsIdsBefore.includes(clientSocket.subscribedEnseignantId)
      });
      
      if (clientSocket.subscribedEnseignantId && enseignantsIdsBefore.includes(clientSocket.subscribedEnseignantId)) {
        console.log(`üì§ Envoi de mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId} apr√®s remplacement`);
        sendTeacherUpdate(clientSocket, clientSocket.subscribedEnseignantId);
      }
    });
    
    res.json(updatedCours);
  } catch (error) {
    console.error('Erreur lors du remplacement du cours:', error);
    res.status(500).json({ message: error.message });
  }
});

app.delete('/api/cours/:id', async (req, res) => {
  try {
    // R√©cup√©rer le cours avant de le supprimer pour avoir les informations des enseignants
    const coursToDelete = await Cours.findById(req.params.id);
    if (!coursToDelete) {
      res.status(404).json({ message: 'Cours non trouv√©' });
      return;
    }
    
    // Extraire les IDs des enseignants du cours
    const enseignantsIds = coursToDelete.enseignants.map(e => e.id.toString());
    console.log('üóëÔ∏è Suppression du cours pour les enseignants:', enseignantsIds);
    
    // Supprimer le cours
    await Cours.findByIdAndDelete(req.params.id);
    const coursList = await Cours.find({});
    io.emit('coursUpdate', coursList);
    
    // Envoyer une mise √† jour sp√©cifique √† tous les enseignants concern√©s
    console.log('üì§ Envoi de mises √† jour aux enseignants apr√®s suppression:', enseignantsIds);
    console.log('üîå Sockets connect√©s:', io.sockets.sockets.size);
    
    // Parcourir tous les sockets connect√©s et envoyer les mises √† jour
    io.sockets.sockets.forEach((clientSocket) => {
      console.log(`üîç V√©rification du socket ${clientSocket.id}:`, {
        subscribedEnseignantId: clientSocket.subscribedEnseignantId,
        enseignantsIds: enseignantsIds,
        isMatch: clientSocket.subscribedEnseignantId && enseignantsIds.includes(clientSocket.subscribedEnseignantId)
      });
      
      if (clientSocket.subscribedEnseignantId && enseignantsIds.includes(clientSocket.subscribedEnseignantId)) {
        console.log(`üì§ Envoi de mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId} apr√®s suppression`);
        sendTeacherUpdate(clientSocket, clientSocket.subscribedEnseignantId);
      }
    });
    
    res.json({ message: 'Cours supprim√©' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Modifier la route pour les statistiques des enseignants
app.get('/api/stats/enseignants', async (req, res) => {
  try {
    const stats = await Cours.aggregate([
      { $unwind: '$enseignantsIds' },
      { $group: { 
        _id: '$enseignantsIds',
        count: { $sum: 1 }
      }},
      { $lookup: {
        from: 'enseignants',
        localField: '_id',
        foreignField: '_id',
        as: 'enseignant'
      }},
      { $unwind: '$enseignant' },
      { $project: {
        nom: '$enseignant.nom',
        count: 1
      }}
    ]);
    
    res.json(stats);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// Fonction helper pour envoyer les mises √† jour sp√©cifiques √† l'enseignant
const sendTeacherUpdate = async (socket, enseignantId) => {
  if (!enseignantId) {
    console.log('‚ùå Aucun enseignant abonn√©, pas de mise √† jour envoy√©e');
    return;
  }
  
  try {
    console.log(`üîç Recherche des cours pour l'enseignant ${enseignantId}...`);
    
    // R√©cup√©rer la semaine et l'ann√©e actuelles
    const today = new Date();
    const currentWeek = getWeekNumber(today);
    const currentYear = today.getFullYear();
    
    console.log(`üìÖ Filtrage pour la semaine ${currentWeek} de ${currentYear}`);
    
    const enseignantCours = await Cours.find({
      'enseignants.id': enseignantId.toString(),
      semaine: currentWeek,
      annee: currentYear
    });
    
    console.log(`üìö Cours trouv√©s pour l'enseignant (semaine ${currentWeek}): ${enseignantCours.length}`);
    
    const enseignantSurveillances = await Surveillance.find({
      enseignant: enseignantId.toString(),
      semaine: currentWeek,
      annee: currentYear
    }).populate('enseignant uhr');
    
    console.log(`üëÅÔ∏è Surveillances trouv√©es pour l'enseignant (semaine ${currentWeek}): ${enseignantSurveillances.length}`);
    
    const updateData = { 
      cours: enseignantCours, 
      surveillances: enseignantSurveillances, 
      uhrs: uhrs,
      currentWeek: currentWeek,
      currentYear: currentYear
    };
    
    console.log('üì§ Envoi de la mise √† jour:', {
      enseignantId,
      semaine: currentWeek,
      annee: currentYear,
      coursCount: enseignantCours.length,
      surveillancesCount: enseignantSurveillances.length,
      uhrsCount: uhrs.length
    });
    
    socket.emit('planningUpdate', updateData);
    
    console.log(`‚úÖ Mise √† jour envoy√©e √† l'enseignant ${enseignantId}`);
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'envoi de la mise √† jour:', error);
  }
};

// Fonction helper pour envoyer les mises √† jour sp√©cifiques √† une classe
const sendClassUpdate = async (socket, classeNom) => {
  if (!classeNom) {
    console.log('‚ùå Aucune classe abonn√©e, pas de mise √† jour envoy√©e');
    return;
  }
  
  try {
    console.log(`üîç Recherche des cours pour la classe ${classeNom}...`);
    
    // R√©cup√©rer la semaine et l'ann√©e actuelles
    const today = new Date();
    const currentWeek = getWeekNumber(today);
    const currentYear = today.getFullYear();
    
    console.log(`üìÖ Filtrage pour la semaine ${currentWeek} de ${currentYear}`);
    
    const classeCours = await Cours.find({
      classe: classeNom,
      semaine: currentWeek,
      annee: currentYear
    });
    
    console.log(`üìö Cours trouv√©s pour la classe (semaine ${currentWeek}): ${classeCours.length}`);
    
    const updateData = { 
      cours: classeCours, 
      uhrs: uhrs,
      currentWeek: currentWeek,
      currentYear: currentYear
    };
    
    console.log('üì§ Envoi de la mise √† jour:', {
      classeNom,
      semaine: currentWeek,
      annee: currentYear,
      coursCount: classeCours.length,
      uhrsCount: uhrs.length
    });
    
    socket.emit('planningUpdate', updateData);
    
    console.log(`‚úÖ Mise √† jour envoy√©e √† la classe ${classeNom}`);
  } catch (error) {
    console.error('‚ùå Erreur lors de l\'envoi de la mise √† jour:', error);
  }
};

// Gestion des mises √† jour en temps r√©el avec Socket.IO
io.on('connection', (socket) => {
  console.log('Nouvelle connexion Socket.IO');

  // Stocker l'ID de l'enseignant ou le nom de la classe pour ce socket
  let subscribedEnseignantId = null;
  let subscribedClasseNom = null;

  // G√©rer l'abonnement d'un enseignant ou d'une classe
  socket.on('subscribe', async (data) => {
    try {
      console.log('üì° Abonnement re√ßu:', data);
      console.log('üîå Sockets connect√©s:', io.sockets.sockets.size);
      console.log('üìã Liste des sockets abonn√©s:', Array.from(io.sockets.sockets.values()).map(s => ({
        enseignantId: s.subscribedEnseignantId,
        classeNom: s.subscribedClasseNom
      })).filter(s => s.enseignantId || s.classeNom));
      
      // V√©rifier si c'est un abonnement d'enseignant ou de classe
      if (data.enseignantId) {
        subscribedEnseignantId = data.enseignantId;
        subscribedClasseNom = null;
        
        // Stocker l'ID de l'enseignant sur le socket
        socket.subscribedEnseignantId = data.enseignantId;
        socket.subscribedClasseNom = null;
        
        // R√©cup√©rer la semaine et l'ann√©e actuelles
        const today = new Date();
        const currentWeek = getWeekNumber(today);
        const currentYear = today.getFullYear();
        
        console.log(`üîç Recherche des cours pour l'enseignant ${subscribedEnseignantId} (semaine ${currentWeek})...`);
        const enseignantCours = await Cours.find({
          'enseignants.id': subscribedEnseignantId.toString(),
          semaine: currentWeek,
          annee: currentYear
        });
        
        console.log(`üìö Cours trouv√©s pour l'enseignant (semaine ${currentWeek}): ${enseignantCours.length}`);
        
        const enseignantSurveillances = await Surveillance.find({
          enseignant: subscribedEnseignantId.toString(),
          semaine: currentWeek,
          annee: currentYear
        }).populate('enseignant uhr');
        
        console.log(`üëÅÔ∏è Surveillances trouv√©es pour l'enseignant (semaine ${currentWeek}): ${enseignantSurveillances.length}`);
        
        const updateData = { 
          cours: enseignantCours, 
          surveillances: enseignantSurveillances, 
          uhrs: uhrs,
          currentWeek: currentWeek,
          currentYear: currentYear
        };
        
        console.log('üì§ Envoi des donn√©es initiales:', {
          enseignantId: subscribedEnseignantId,
          semaine: currentWeek,
          annee: currentYear,
          coursCount: enseignantCours.length,
          surveillancesCount: enseignantSurveillances.length,
          uhrsCount: uhrs.length
        });
        
        socket.emit('planningUpdate', updateData);
        
        console.log(`‚úÖ Enseignant ${subscribedEnseignantId} abonn√© aux mises √† jour`);
        
      } else if (data.classeId) {
        subscribedClasseNom = data.classeId;
        subscribedEnseignantId = null;
        
        // Stocker le nom de la classe sur le socket
        socket.subscribedClasseNom = data.classeId;
        socket.subscribedEnseignantId = null;
        
        // R√©cup√©rer la semaine et l'ann√©e actuelles
        const today = new Date();
        const currentWeek = getWeekNumber(today);
        const currentYear = today.getFullYear();
        
        console.log(`üîç Recherche des cours pour la classe ${subscribedClasseNom} (semaine ${currentWeek})...`);
        const classeCours = await Cours.find({
          classe: subscribedClasseNom,
          semaine: currentWeek,
          annee: currentYear
        });
        
        console.log(`üìö Cours trouv√©s pour la classe (semaine ${currentWeek}): ${classeCours.length}`);
        
        const updateData = { 
          cours: classeCours, 
          uhrs: uhrs,
          currentWeek: currentWeek,
          currentYear: currentYear
        };
        
        console.log('üì§ Envoi des donn√©es initiales:', {
          classeNom: subscribedClasseNom,
          semaine: currentWeek,
          annee: currentYear,
          coursCount: classeCours.length,
          uhrsCount: uhrs.length
        });
        
        socket.emit('planningUpdate', updateData);
        
        console.log(`‚úÖ Classe ${subscribedClasseNom} abonn√©e aux mises √† jour`);
        
      } else {
        throw new Error('Aucun enseignantId ou classeId fourni dans l\'abonnement');
      }
      
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'abonnement:', error);
      socket.emit('error', error.message);
    }
  });

  // Envoyer les donn√©es initiales
  socket.emit('planningUpdate', { planning, surveillances, zeitslots });
  socket.emit('enseignantsUpdate', enseignants);
  socket.emit('coursUpdate', cours);
  socket.emit('classesUpdate', classes);
  socket.emit('matieresUpdate', matieres);
  socket.emit('sallesUpdate', salles);
  socket.emit('uhrsUpdate', uhrs);

  // G√©rer la mise √† jour d'un cr√©neau
  socket.on('updateSlot', async (updatedSlot) => {
    try {
      const result = await Planning.findByIdAndUpdate(
        updatedSlot._id,
        updatedSlot,
        { new: true }
      );
      io.emit('planningUpdate', { planning: await Planning.find({}) });
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  // G√©rer la suppression d'un cr√©neau
  socket.on('deleteSlot', async (slotId) => {
    try {
      const deleted = await Planning.findByIdAndDelete(slotId);
      io.emit('planningUpdate', { planning: await Planning.find({}) });
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  // G√©rer l'ajout d'une nouvelle tranche horaire
  socket.on('addTimeSlot', async (newTimeSlot) => {
    try {
      const existingSlot = await Uhr.findOne({ nummer: newTimeSlot.nummer });
      if (existingSlot) {
        socket.emit('error', 'Num√©ro d√©j√† existant');
        return;
      }

      const uhrData = {
        nummer: newTimeSlot.nummer,
        start: newTimeSlot.start,
        ende: newTimeSlot.ende
      };

      const createdUhr = await Uhr.create(uhrData);
      zeitslots = await Uhr.find({});
      io.emit('uhrsUpdate', zeitslots);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  // G√©rer l'ajout d'un nouveau cours
  socket.on('addCours', async (coursData) => {
    try {
      console.log('Donn√©es re√ßues pour l\'ajout d\'un cours:', coursData);
      
      // R√©cup√©rer les informations des enseignants
      const enseignants = await Promise.all(
        coursData.enseignants.map(async (nom) => {
          const enseignant = await Enseignant.findOne({ nom });
          if (!enseignant) {
            throw new Error(`Enseignant non trouv√©: ${nom}`);
          }
          return {
            nom: enseignant.nom,
            id: enseignant._id
          };
        })
      );

      const newCours = await Cours.create({
        classe: coursData.classe,
        enseignants,
        matiere: coursData.matiere,
        salle: coursData.salle,
        jour: coursData.jour,
        heure: coursData.heure,
        uhr: coursData.uhr,
        semaine: coursData.semaine,
        annee: coursData.annee || new Date().getFullYear(),
        commentaire: coursData.commentaire || ''
      });

      console.log('Nouveau cours cr√©√©:', newCours);
      cours = await Cours.find({});
      
      // Envoyer une mise √† jour √† tous les clients connect√©s
      io.emit('coursUpdate', cours);
      
      // Envoyer une mise √† jour sp√©cifique √† tous les enseignants concern√©s
      const enseignantsIds = enseignants.map(e => e.id.toString());
      const classesNoms = [coursData.classe];
      console.log('üì§ Envoi de mises √† jour aux enseignants:', enseignantsIds);
      console.log('üîå Sockets connect√©s:', io.sockets.sockets.size);
      console.log('üìã Sockets abonn√©s:', Array.from(io.sockets.sockets.values()).map(s => ({
        id: s.id,
        subscribedEnseignantId: s.subscribedEnseignantId
      })));
      
      // Parcourir tous les sockets connect√©s et envoyer les mises √† jour
      io.sockets.sockets.forEach((clientSocket) => {
        console.log(`üîç V√©rification du socket ${clientSocket.id}:`, {
          subscribedEnseignantId: clientSocket.subscribedEnseignantId,
          enseignantsIds: enseignantsIds,
          isMatch: clientSocket.subscribedEnseignantId && enseignantsIds.includes(clientSocket.subscribedEnseignantId)
        });
        
        if (clientSocket.subscribedEnseignantId && enseignantsIds.includes(clientSocket.subscribedEnseignantId)) {
          console.log(`üì§ Envoi de mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId}`);
          sendTeacherUpdate(clientSocket, clientSocket.subscribedEnseignantId);
        }
        if (clientSocket.subscribedClasseNom && classesNoms.includes(clientSocket.subscribedClasseNom)) {
          sendClassUpdate(clientSocket, clientSocket.subscribedClasseNom);
        }
      });
      
      // Envoyer une confirmation de succ√®s
      socket.emit('success', 'Cours ajout√© avec succ√®s');
    } catch (error) {
      console.error('Erreur lors de l\'ajout du cours:', error);
      socket.emit('error', error.message);
    }
  });

  // G√©rer la copie et le collage d'une semaine
  socket.on('pasteWeek', async (data) => {
    try {
      console.log('Demande de copie de semaine re√ßue:', data);
      const { courses, surveillances: surveillancesData, targetWeek, targetYear, sourceWeek, sourceYear } = data;
      
      if ((!courses || !Array.isArray(courses) || courses.length === 0) && 
          (!surveillancesData || !Array.isArray(surveillancesData) || surveillancesData.length === 0)) {
        socket.emit('pasteWeekError', 'Aucun cours ou surveillance √† copier');
        return;
      }
      
      // V√©rifier si nous essayons de coller dans la m√™me semaine
      if (sourceWeek === targetWeek && sourceYear === targetYear) {
        socket.emit('pasteWeekError', 'Impossible de coller dans la m√™me semaine');
        return;
      }
      
      // Ajouter les nouveaux cours
      let successCount = 0;
      let errorCount = 0;
      let surveillanceSuccessCount = 0;
      let surveillanceErrorCount = 0;
      
      // Traiter les cours
      if (courses && Array.isArray(courses) && courses.length > 0) {
        for (const coursData of courses) {
          try {
            // S'assurer que les champs obligatoires sont pr√©sents
            if (!coursData.classe || !coursData.enseignants || !coursData.matiere || 
                !coursData.salle || !coursData.jour || !coursData.heure || !coursData.uhr) {
              console.error('Donn√©es de cours invalides:', coursData);
              errorCount++;
              continue;
            }
            
            await Cours.create({
              classe: coursData.classe,
              enseignants: coursData.enseignants,
              matiere: coursData.matiere,
              salle: coursData.salle,
              jour: coursData.jour,
              heure: coursData.heure,
              uhr: coursData.uhr,
              semaine: targetWeek,
              annee: targetYear,
              annule: coursData.annule || false,
              remplace: coursData.remplace || false,
              remplacementInfo: coursData.remplacementInfo || '',
              commentaire: coursData.commentaire || ''
            });
            
            successCount++;
          } catch (error) {
            console.error('Erreur lors de la cr√©ation d\'un cours:', error);
            errorCount++;
          }
        }
      }
      
      // Traiter les surveillances
      if (surveillancesData && Array.isArray(surveillancesData) && surveillancesData.length > 0) {
        for (const surveillanceData of surveillancesData) {
          try {
            // S'assurer que les champs obligatoires sont pr√©sents
            if (!surveillanceData.enseignant || !surveillanceData.uhr || !surveillanceData.jour) {
              console.error('Donn√©es de surveillance invalides:', surveillanceData);
              surveillanceErrorCount++;
              continue;
            }
            
            await Surveillance.create({
              enseignant: surveillanceData.enseignant,
              lieu: surveillanceData.lieu || '',
              jour: surveillanceData.jour,
              position: surveillanceData.position || -1,
              uhr: surveillanceData.uhr,
              semaine: targetWeek,
              annee: targetYear,
              ordre: surveillanceData.ordre || 0
            });
            
            surveillanceSuccessCount++;
          } catch (error) {
            console.error('Erreur lors de la cr√©ation d\'une surveillance:', error);
            surveillanceErrorCount++;
          }
        }
      }
      
      // Actualiser les cours et surveillances apr√®s l'ajout
      cours = await Cours.find({});
      surveillances = await Surveillance.find({}).populate('enseignant');
      io.emit('coursUpdate', cours);
      io.emit('planningUpdate', { surveillances });
      
      // Envoyer une mise √† jour sp√©cifique √† tous les enseignants concern√©s
      const enseignantsIds = courses ? courses.flatMap(c => c.enseignants.map(e => (e.id || e._id).toString())).filter((id, index, arr) => arr.indexOf(id) === index) : [];
      const classesNoms = courses ? courses.map(c => c.classe) : [];
      console.log('üì§ Envoi de mises √† jour aux enseignants (pasteWeek):', enseignantsIds);
      
      // Parcourir tous les sockets connect√©s et envoyer les mises √† jour
      io.sockets.sockets.forEach((clientSocket) => {
        if (clientSocket.subscribedEnseignantId && enseignantsIds.includes(clientSocket.subscribedEnseignantId)) {
          console.log(`üì§ Envoi de mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId}`);
          sendTeacherUpdate(clientSocket, clientSocket.subscribedEnseignantId);
        }
      });
      
      // Envoyer une r√©ponse
      const totalSuccess = successCount + surveillanceSuccessCount;
      const totalErrors = errorCount + surveillanceErrorCount;
      
      if (totalErrors === 0) {
        let message = '';
        if (successCount > 0 && surveillanceSuccessCount > 0) {
          message = `${successCount} cours et ${surveillanceSuccessCount} surveillances copi√©s avec succ√®s`;
        } else if (successCount > 0) {
          message = `${successCount} cours copi√©s avec succ√®s`;
        } else if (surveillanceSuccessCount > 0) {
          message = `${surveillanceSuccessCount} surveillances copi√©es avec succ√®s`;
        }
        
        socket.emit('pasteWeekSuccess', { 
          message: message,
          copied: totalSuccess,
          coursesCopied: successCount,
          surveillancesCopied: surveillanceSuccessCount
        });
      } else {
        let message = '';
        if (successCount > 0 && surveillanceSuccessCount > 0) {
          message = `${successCount} cours et ${surveillanceSuccessCount} surveillances copi√©s avec succ√®s, ${totalErrors} erreurs`;
        } else if (successCount > 0) {
          message = `${successCount} cours copi√©s avec succ√®s, ${totalErrors} erreurs`;
        } else if (surveillanceSuccessCount > 0) {
          message = `${surveillanceSuccessCount} surveillances copi√©es avec succ√®s, ${totalErrors} erreurs`;
        }
        
        socket.emit('pasteWeekSuccess', { 
          message: message,
          copied: totalSuccess,
          errors: totalErrors,
          coursesCopied: successCount,
          surveillancesCopied: surveillanceSuccessCount
        });
      }
    } catch (error) {
      console.error('Erreur lors de la copie de la semaine:', error);
      socket.emit('pasteWeekError', error.message);
    }
  });

  // Gestion de la suppression d'une tranche horaire
  socket.on('deleteTimeSlot', async (timeSlotId) => {
    try {
      await Uhr.findByIdAndDelete(timeSlotId);
      zeitslots = await Uhr.find({});
      io.emit('uhrsUpdate', zeitslots);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  // Gestion des surveillances
  socket.on('addSurveillance', async (surveillanceData) => {
    try {
      console.log('Donn√©es re√ßues pour l\'ajout de surveillance:', JSON.stringify(surveillanceData, null, 2));
      
      // V√©rifier que toutes les donn√©es requises sont pr√©sentes
      if (!surveillanceData.annee) {
        console.error('L\'ann√©e est manquante dans les donn√©es re√ßues');
        throw new Error('L\'ann√©e est requise pour la surveillance');
      }

      // V√©rifier que uhr est pr√©sent
      if (!surveillanceData.uhr) {
        console.error('Le cr√©neau horaire est manquant dans les donn√©es re√ßues');
        throw new Error('Le cr√©neau horaire est requis pour la surveillance');
      }

      // V√©rifier que enseignant est pr√©sent
      if (!surveillanceData.enseignant) {
        console.error('L\'enseignant est manquant dans les donn√©es re√ßues');
        throw new Error('L\'enseignant est requis pour la surveillance');
      }

      console.log('Tentative de cr√©ation de la surveillance...');
      const newSurveillance = await Surveillance.create(surveillanceData);
      console.log('Nouvelle surveillance cr√©√©e:', JSON.stringify(newSurveillance, null, 2));
      
      console.log('R√©cup√©ration de la liste mise √† jour des surveillances...');
      surveillances = await Surveillance.find({}).populate('enseignant');
      console.log('Liste mise √† jour des surveillances:', JSON.stringify(surveillances, null, 2));
      
      console.log('Envoi de la mise √† jour aux clients...');
      io.emit('planningUpdate', { surveillances });
      socket.emit('surveillanceAdded', newSurveillance);
      console.log('Mise √† jour envoy√©e avec succ√®s');
    } catch (error) {
      console.error('Erreur lors de l\'ajout de la surveillance:', error);
      socket.emit('surveillanceError', error.message);
    }
  });

  socket.on('updateSurveillance', async (surveillanceData) => {
    try {
      await Surveillance.findByIdAndUpdate(
        surveillanceData._id,
        surveillanceData,
        { new: true }
      );
      surveillances = await Surveillance.find({}).populate('enseignant');
      io.emit('planningUpdate', { surveillances });
      socket.emit('surveillanceUpdated');
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('deleteSurveillance', async (surveillanceId) => {
    try {
      await Surveillance.findByIdAndDelete(surveillanceId);
      surveillances = await Surveillance.find({}).populate('enseignant');
      io.emit('planningUpdate', { surveillances });
      socket.emit('surveillanceDeleted');
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  // Gestionnaire pour obtenir les surveillances
  socket.on('getSurveillances', async () => {
    try {
      surveillances = await Surveillance.find({}).populate('enseignant');
      socket.emit('planningUpdate', { surveillances });
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  // Gestion des enseignants
  socket.on('getEnseignants', async () => {
    try {
      enseignants = await Enseignant.find({});
      socket.emit('enseignantsUpdate', enseignants);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('addEnseignant', async (enseignantData) => {
    try {
      const enseignant = await Enseignant.create(enseignantData);
      enseignants = await Enseignant.find({});
      io.emit('enseignantsUpdate', enseignants);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('updateEnseignant', async (enseignantData) => {
    try {
      await Enseignant.findByIdAndUpdate(
        enseignantData._id,
        enseignantData,
        { new: true }
      );
      enseignants = await Enseignant.find({});
      io.emit('enseignantsUpdate', enseignants);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('deleteEnseignant', async (enseignantId) => {
    try {
      await Enseignant.findByIdAndDelete(enseignantId);
      enseignants = await Enseignant.find({});
      io.emit('enseignantsUpdate', enseignants);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  // Socket.IO events pour les mati√®res
  socket.on('getMatieres', async () => {
    try {
      matieres = await Matiere.find({});
      socket.emit('matieresUpdate', matieres);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('addMatiere', async (matiereData) => {
    try {
      const matiere = await Matiere.create(matiereData);
      matieres = await Matiere.find({});
      io.emit('matieresUpdate', matieres);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('updateMatiere', async (matiereData) => {
    try {
      await Matiere.findByIdAndUpdate(matiereData._id, matiereData);
      const matieres = await Matiere.find({});
      io.emit('matieresUpdate', matieres);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('deleteMatiere', async (id) => {
    try {
      await Matiere.findByIdAndDelete(id);
      const matieres = await Matiere.find({});
      io.emit('matieresUpdate', matieres);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  // Socket.IO events pour les classes
  socket.on('getClasses', async () => {
    try {
      classes = await Classe.find({});
      socket.emit('classesUpdate', classes);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('addClasse', async (classeData) => {
    try {
      const classe = await Classe.create(classeData);
      classes = await Classe.find({});
      io.emit('classesUpdate', classes);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('updateClasse', async (classeData) => {
    try {
      await Classe.findByIdAndUpdate(classeData._id, classeData);
      const classes = await Classe.find({});
      io.emit('classesUpdate', classes);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('deleteClasse', async (id) => {
    try {
      await Classe.findByIdAndDelete(id);
      const classes = await Classe.find({});
      io.emit('classesUpdate', classes);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  // Socket.IO events pour les salles
  socket.on('getSalles', async () => {
    try {
      salles = await Salle.find({});
      socket.emit('sallesUpdate', salles);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('addSalle', async (salleData) => {
    try {
      const salle = await Salle.create(salleData);
      salles = await Salle.find({});
      io.emit('sallesUpdate', salles);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('updateSalle', async (salleData) => {
    try {
      await Salle.findByIdAndUpdate(salleData._id, salleData);
      const salles = await Salle.find({});
      io.emit('sallesUpdate', salles);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('deleteSalle', async (id) => {
    try {
      await Salle.findByIdAndDelete(id);
      const salles = await Salle.find({});
      io.emit('sallesUpdate', salles);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  // Gestionnaire pour obtenir les cours
  socket.on('getCours', async () => {
    try {
      cours = await Cours.find({});
      socket.emit('coursUpdate', cours);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('updateCours', async (coursData) => {
    try {
      console.log('Mise √† jour du cours re√ßue:', coursData);
      
      // V√©rifier que l'ID du cours est valide
      if (!coursData._id) {
        throw new Error('ID de cours invalide');
      }
      
      // Trouver le cours existant
      const existingCours = await Cours.findById(coursData._id);
      if (!existingCours) {
        throw new Error('Cours non trouv√©');
      }
      
      // Mettre √† jour le cours avec les nouvelles donn√©es
      Object.keys(coursData).forEach(key => {
        if (key !== '_id') {
          existingCours[key] = coursData[key];
        }
      });
      
      // Sauvegarder les modifications
      await existingCours.save();
      
      console.log('Cours mis √† jour avec succ√®s:', existingCours);
      
      // √âmettre les donn√©es mises √† jour
      const cours = await Cours.find();
      socket.emit('coursUpdate', cours);
      socket.broadcast.emit('coursUpdate', cours);
      
      socket.emit('success', 'Cours mis √† jour avec succ√®s');
    } catch (error) {
      console.error('Erreur lors de la mise √† jour du cours:', error);
      socket.emit('error', error.message);
    }
  });

  socket.on('deleteCours', async (id) => {
    try {
      // R√©cup√©rer le cours avant de le supprimer pour avoir les informations des enseignants
      const coursToDelete = await Cours.findById(id);
      if (!coursToDelete) {
        socket.emit('error', 'Cours non trouv√©');
        return;
      }
      
      // Extraire les IDs des enseignants du cours
      const enseignantsIds = coursToDelete.enseignants.map(e => e.id.toString());
      console.log('üóëÔ∏è Suppression du cours pour les enseignants:', enseignantsIds);
      
      // Supprimer le cours
      await Cours.findByIdAndDelete(id);
      const coursList = await Cours.find({});
      io.emit('coursUpdate', coursList);
      
      // Envoyer une mise √† jour sp√©cifique √† tous les enseignants concern√©s
      console.log('üì§ Envoi de mises √† jour aux enseignants apr√®s suppression:', enseignantsIds);
      console.log('üîå Sockets connect√©s:', io.sockets.sockets.size);
      
      // Parcourir tous les sockets connect√©s et envoyer les mises √† jour
      io.sockets.sockets.forEach((clientSocket) => {
        console.log(`üîç V√©rification du socket ${clientSocket.id}:`, {
          subscribedEnseignantId: clientSocket.subscribedEnseignantId,
          enseignantsIds: enseignantsIds,
          isMatch: clientSocket.subscribedEnseignantId && enseignantsIds.includes(clientSocket.subscribedEnseignantId)
        });
        
        if (clientSocket.subscribedEnseignantId && enseignantsIds.includes(clientSocket.subscribedEnseignantId)) {
          console.log(`üì§ Envoi de mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId} apr√®s suppression`);
          sendTeacherUpdate(clientSocket, clientSocket.subscribedEnseignantId);
        }
      });
      
      socket.emit('success', 'Cours supprim√© avec succ√®s');
    } catch (error) {
      console.error('Erreur lors de la suppression du cours:', error);
      socket.emit('error', error.message);
    }
  });

  // Gestionnaire pour obtenir les heures
  socket.on('getUhrs', async () => {
    try {
      zeitslots = await Uhr.find({});
      socket.emit('uhrsUpdate', zeitslots);
    } catch (error) {
      socket.emit('error', error.message);
    }
  });

  socket.on('addUhr', async (uhrData) => {
    try {
      console.log('‚ûï √âv√©nement addUhr re√ßu:', uhrData);
      
      const newUhr = await Uhr.create(uhrData);
      console.log('‚úÖ Nouvelle tranche horaire cr√©√©e:', newUhr);
      
      zeitslots = await Uhr.find({});
      console.log('üì§ Envoi de la mise √† jour des tranches horaires:', zeitslots);
      io.emit('uhrsUpdate', zeitslots);
      
      console.log('‚úÖ Ajout de tranche horaire envoy√© avec succ√®s');
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'ajout de la tranche horaire:', error);
      socket.emit('error', error.message);
    }
  });

  socket.on('updateUhr', async (uhrData) => {
    try {
      console.log('üïê √âv√©nement updateUhr re√ßu:', uhrData);
      
      const updatedUhr = await Uhr.findByIdAndUpdate(uhrData._id, uhrData, { new: true });
      console.log('‚úÖ Tranche horaire mise √† jour:', updatedUhr);
      
      zeitslots = await Uhr.find({});
      console.log('üì§ Envoi de la mise √† jour des tranches horaires:', zeitslots);
      io.emit('uhrsUpdate', zeitslots);
      
      console.log('‚úÖ Mise √† jour des tranches horaires envoy√©e avec succ√®s');
    } catch (error) {
      console.error('‚ùå Erreur lors de la mise √† jour de la tranche horaire:', error);
      socket.emit('error', error.message);
    }
  });

  socket.on('deleteUhr', async (uhrId) => {
    try {
      console.log('üóëÔ∏è √âv√©nement deleteUhr re√ßu pour l\'ID:', uhrId);
      
      const deletedUhr = await Uhr.findByIdAndDelete(uhrId);
      console.log('‚úÖ Tranche horaire supprim√©e:', deletedUhr);
      
      zeitslots = await Uhr.find({});
      console.log('üì§ Envoi de la mise √† jour des tranches horaires:', zeitslots);
      io.emit('uhrsUpdate', zeitslots);
      
      console.log('‚úÖ Suppression de tranche horaire envoy√©e avec succ√®s');
    } catch (error) {
      console.error('‚ùå Erreur lors de la suppression de la tranche horaire:', error);
      socket.emit('error', error.message);
    }
  });

  // G√©rer l'annulation d'un cours
  socket.on('cancelCours', async (coursId) => {
    try {
      console.log('üö´ √âv√©nement cancelCours re√ßu pour le cours:', coursId);
      
      // R√©cup√©rer le cours avant de le modifier pour avoir les informations des enseignants
      const coursToUpdate = await Cours.findById(coursId);
      if (!coursToUpdate) {
        console.log('‚ùå Cours non trouv√©:', coursId);
        socket.emit('error', 'Cours non trouv√©');
        return;
      }
      
      // Extraire les IDs des enseignants du cours
      const enseignantsIds = coursToUpdate.enseignants.map(e => e.id.toString());
      console.log('üö´ Annulation du cours pour les enseignants:', enseignantsIds);
      
      // Marquer le cours comme annul√© au lieu de le supprimer
      const updatedCours = await Cours.findByIdAndUpdate(
        coursId,
        { annule: true, remplace: false },
        { new: true }
      );
      
      console.log('‚úÖ Cours marqu√© comme annul√©:', updatedCours._id);
      
      // Envoyer une mise √† jour sp√©cifique √† tous les enseignants concern√©s
      console.log('üì§ Envoi de mises √† jour aux enseignants apr√®s annulation:', enseignantsIds);
      console.log('üîå Sockets connect√©s:', io.sockets.sockets.size);
      
      // Parcourir tous les sockets connect√©s et envoyer les mises √† jour
      io.sockets.sockets.forEach((clientSocket) => {
        console.log(`üîç V√©rification du socket ${clientSocket.id}:`, {
          subscribedEnseignantId: clientSocket.subscribedEnseignantId,
          enseignantsIds: enseignantsIds,
          isMatch: clientSocket.subscribedEnseignantId && enseignantsIds.includes(clientSocket.subscribedEnseignantId)
        });
        
        if (clientSocket.subscribedEnseignantId && enseignantsIds.includes(clientSocket.subscribedEnseignantId)) {
          console.log(`üì§ Envoi de mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId} apr√®s annulation`);
          try {
            sendTeacherUpdate(clientSocket, clientSocket.subscribedEnseignantId);
            console.log(`‚úÖ Mise √† jour envoy√©e avec succ√®s √† l'enseignant ${clientSocket.subscribedEnseignantId}`);
          } catch (error) {
            console.error(`‚ùå Erreur lors de l'envoi de la mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId}:`, error);
          }
        }
      });
      
      socket.emit('success', 'Cours annul√© avec succ√®s');
    } catch (error) {
      console.error('Erreur lors de l\'annulation du cours:', error);
      socket.emit('error', error.message);
    }
  });

  // G√©rer le remplacement d'un cours
  socket.on('replaceCours', async (coursData) => {
    try {
      // R√©cup√©rer le cours avant de le modifier pour avoir les informations des enseignants
      const coursToUpdate = await Cours.findById(coursData._id);
      if (!coursToUpdate) {
        socket.emit('error', 'Cours non trouv√©');
        return;
      }
      
      // Extraire les IDs des enseignants du cours (avant et apr√®s modification)
      const enseignantsIdsBefore = coursToUpdate.enseignants.map(e => e.id.toString());
      const enseignantsIdsAfter = coursData.enseignants.map(e => e.id.toString());
      const allEnseignantsIds = [...new Set([...enseignantsIdsBefore, ...enseignantsIdsAfter])];
      
      console.log('üîÑ Remplacement du cours pour les enseignants:', allEnseignantsIds);
      
      // Mettre √† jour le cours
      await Cours.findByIdAndUpdate(coursData._id, coursData, { new: true });
      cours = await Cours.find({});
      io.emit('coursUpdate', cours);
      
      // Envoyer une mise √† jour sp√©cifique √† tous les enseignants concern√©s
      console.log('üì§ Envoi de mises √† jour aux enseignants apr√®s remplacement:', allEnseignantsIds);
      
      // Parcourir tous les sockets connect√©s et envoyer les mises √† jour
      io.sockets.sockets.forEach((clientSocket) => {
        if (clientSocket.subscribedEnseignantId && allEnseignantsIds.includes(clientSocket.subscribedEnseignantId)) {
          console.log(`üì§ Envoi de mise √† jour √† l'enseignant ${clientSocket.subscribedEnseignantId} apr√®s remplacement`);
          sendTeacherUpdate(clientSocket, clientSocket.subscribedEnseignantId);
        }
      });
      
      socket.emit('success', 'Cours remplac√© avec succ√®s');
    } catch (error) {
      console.error('Erreur lors du remplacement du cours:', error);
      socket.emit('error', error.message);
    }
  });

  // Routes pour les annotations
  socket.on('saveAnnotation', async (data) => {
    try {
      const { jour, annotation, semaine, date, annee } = data;
      
      if (!jour || !semaine || !date || !annee) {
        throw new Error('Donn√©es manquantes pour la sauvegarde de l\'annotation');
      }

      // Normaliser le format du jour
      const normalizedJour = jour.charAt(0).toUpperCase() + jour.slice(1).toLowerCase();
      
      // Rechercher une annotation existante pour ce jour et cette semaine
      let existingAnnotation = await Annotation.findOne({ 
        jour: normalizedJour, 
        semaine: semaine,
        annee: annee
      });

      if (existingAnnotation) {
        // Mettre √† jour l'annotation existante
        existingAnnotation.annotation = annotation;
        existingAnnotation.date = new Date(date);
        await existingAnnotation.save();
      } else {
        // Cr√©er une nouvelle annotation
        existingAnnotation = await Annotation.create({ 
          jour: normalizedJour, 
          annotation, 
          semaine,
          annee,
          date: new Date(date)
        });
      }
      
      // R√©cup√©rer toutes les annotations pour la semaine actuelle
      const annotations = await Annotation.find({
        semaine: semaine,
        annee: annee
      });
      
      const annotationsMap = {};
      annotations.forEach(ann => {
        annotationsMap[ann.jour] = ann.annotation;
      });
      
      // Envoyer les annotations mises √† jour √† tous les clients
      io.emit('annotationsUpdate', annotationsMap);
    } catch (error) {
      console.error('Erreur lors de la sauvegarde de l\'annotation:', error);
      socket.emit('annotationError', error.message);
    }
  });

  socket.on('getAnnotations', async (data) => {
    try {
      console.log('Donn√©es re√ßues:', data);
      
      // V√©rifier que les donn√©es sont valides
      if (!data || typeof data.semaine === 'undefined' || typeof data.annee === 'undefined') {
        console.error('Donn√©es invalides:', data);
        throw new Error('Donn√©es invalides pour la recherche d\'annotations');
      }

      const semaine = Number(data.semaine);
      const annee = Number(data.annee);
      
      console.log('Recherche d\'annotations pour la semaine', semaine, 'et l\'ann√©e', annee);

      const annotations = await Annotation.find({
        semaine: semaine,
        annee: annee
      });
      
      console.log('Annotations trouv√©es:', annotations);
      
      const annotationsMap = {};
      annotations.forEach(ann => {
        annotationsMap[ann.jour] = ann.annotation;
      });
      
      socket.emit('annotationsUpdate', annotationsMap);
    } catch (error) {
      console.error('Erreur lors de la r√©cup√©ration des annotations:', error);
      socket.emit('annotationError', error.message);
    }
  });

  socket.on('disconnect', () => {
    socket.emit('error', 'Client d√©connect√©');
  });
});

// Routes de base
app.get('/', (req, res) => {
  res.json({ message: 'Bienvenue sur l\'API Geco-SchoolPlan' });
});

// Gestion des erreurs globales
app.use((err, req, res, next) => {
  console.error('‚ùå Erreur serveur:', err);
  res.status(500).json({ 
    success: false,
    message: 'Une erreur est survenue sur le serveur',
    error: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

// Port d'√©coute
const PORT = process.env.PORT || 5000;
server.listen(PORT, () => {
  console.log(`üöÄ Serveur d√©marr√© sur le port ${PORT}`);
});

// Int√©gration des routes mobiles
const mobileApi = require('./mobile-api');
mobileApi(app, { checkLoginAttempts, defaultUsers, JWT_SECRET, loginAttempts });

app.post('/api/update-uhr', async (req, res) => {
  try {
    const { _id, nummer, zeitslot } = req.body;
    const updatedUhr = await Uhr.findByIdAndUpdate(
      _id,
      { nummer, zeitslot },
      { new: true }
    );
    io.emit('uhrsUpdate', await Uhr.find());
    res.json(updatedUhr);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

app.post('/api/surveillances', async (req, res) => {
  try {
    const surveillanceData = req.body;
    if (!surveillanceData.annee) {
      res.status(400).json({ error: 'L\'ann√©e est manquante' });
      return;
    }
    if (!surveillanceData.uhr) {
      res.status(400).json({ error: 'Le cr√©neau horaire est manquant' });
      return;
    }
    if (!surveillanceData.enseignant) {
      res.status(400).json({ error: 'L\'enseignant est manquant' });
      return;
    }
    const newSurveillance = await Surveillance.create(surveillanceData);
    const surveillances = await Surveillance.find({}).populate('enseignant');
    io.emit('surveillancesUpdate', surveillances);
    res.status(201).json(newSurveillance);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
